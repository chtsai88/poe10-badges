#pragma config(Sensor, in1,    potentiometer,  sensorPotentiometer)
#pragma config(Sensor, in4,    lightSensor,    sensorReflection)
#pragma config(Sensor, dgtl1,  touch1,         sensorTouch)
#pragma config(Sensor, dgtl2,  touch2,         sensorTouch)
#pragma config(Sensor, dgtl3,  touch3,         sensorTouch)
#pragma config(Sensor, dgtl9,  encoder,        sensorQuadEncoder)
#pragma config(Sensor, dgtl11, sonar,          sensorSONAR_mm)
#pragma config(Motor,  port4,           servo,         tmotorServoStandard, openLoop)+
#pragma config(Motor,  port5,           light,         tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor,  port8,           motorLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           motorRight,    tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*

Project Title: Merit Badge
Team Members: Charles Tsai, Tyler Mead, Nick Kasten
Date: 9/13/19
Section: 4 to 7


Task Description:
Demo program to illustrate motor controls via delays.

Flow Chart:
   /-------\
   | Start |
   \-------/
    |
    v
   +--------------------+
   | Clear Debug Stream |
   +--------------------+
    |
    v
   +------------------------------+
+->| Is the first button pressed? |
|  +------------------------------+
|   N  Y
|   |  |
|   |  v
|   | +-------------------------------+
|   | | Turn left motor for 5 seconds |
|   | +-------------------------------+
|   |  |
|   v  v
|  +-------------------------------+
|  | Is the second button pressed? |
|  +-------------------------------+
|   N  Y
|   |  |
|   |  v
|   | +----------------------+
|   | | Turn left for 1 turn |
|   | +----------------------+
|   |  |
|   |  v
|   | +-------------------------------------+
|   | | Turn right for 1 turn at half speed |
|   | +-------------------------------------+
|   |  |
|   v  v
|  +------------------------------+
|  | Is the third button pressed? |
|  +------------------------------+
|   N  Y
|   |  |
|   |  v
|   | +-----------------------------+
|   | | Have we turned 4 times yet? |
|   | +-----------------------------+
|   |  Y ^  N
|   |  | |  |
|   |  | |  v
|   |  | | +---------------------+
|   |  | | | Move forward 3 feet |
|   |  | | +---------------------+
|   |  | |  |
|   |  | |  v
|   |  | | +--------------------------+
|   |  | | | Turn left at right angle |
|   |  | | +--------------------------+
|   |  | |  |
|   |  | +--+
|   v  v
|  +-------------------------------+
|  | Is the fourth button pressed? |
|  +-------------------------------+
|   N  Y
|   |  |
|   |  v
|   | +-----------------------------+
|   | | Have we turned 4 times yet? |
|   | +-----------------------------+
|   |  Y ^  N
|   |  | |  |
|   |  | |  v
|   |  | | +---------------------+
|   |  | | | Move forward 3 feet |
|   |  | | +---------------------+
|   |  | |  |
|   |  | |  v
|   |  | | +--------------------------+
|   |  | | | Turn left at right angle |
|   |  | | +--------------------------+
|   |  | |  |
+---+--+ +--+


Measurement References:
+--------------------+---------------------------+----------------------------+
| Type               | Range / Expected Range    | Notes                      |
+--------------------+---------------------------+----------------------------+
| Light Sensor       | ~5 to ~1100 / 0 to 4095   | Actually darkness sensor   |
| Touch Sensor       | 0 to 1                    |                            |
| Potentiometer      | 0 to 4095                 | Turn from 0 to 265 degrees |
| Quadrature Encoder | -32767 to 32767           | In degrees                 |
| Sonar (raw)        | ~200 to ~10000 / none     | Return -1 for errors       |
| Line Tracker       | ~120 to ~2500 / 0 to 4095 | Higher values means a line |
+--------------------+---------------------------+----------------------------+

*/
void badge11() {
    setServo(servo, 127);
    static int angle = 127;
    while(!SensorValue[touch3]){
    	if(SensorValue[lightSensor] < 100){
    		if(angle == -127){
    			setServo(servo, 127);
    			angle = 127;
    		} else if(angle == 127){
    			setServo(servo, -127);
   		  	angle = -127;
     		}
       	delay (400);
   		}
   	}
}

void badge12() {
  setServo(servo, 127);
  static int angle = 127;
  clearTimer(T1);
  while(!SensorValue[touch3]){
  	if(getTimer(T1, milliseconds) > 400 && SensorValue[lightSensor] > 150){
      if(angle == -127){
  			setServo(servo, 127);
  			angle = 127;
  		} else if (angle == 127){
  			setServo(servo, -127);
 		  	angle = -127;
   		}
      clearTimer(T1);
 		}
    startMotor(motorLeft, 127);
    startMotor(motorRight, SensorValue[sonar] < 470 ? 0 : 127);
 	}
}

void badge13() {
  setServo(servo, 127);
 	for (int i = 0; i < 3; i++) {
    startMotor(motorLeft, 127);
    startMotor(motorRight, 127);
    while (SensorValue[sonar] == -1 || SensorValue[sonar] >= 800) {}
    startMotor(motorLeft, 63);
    stopMotor(motorRight);
    delay(1000);
    stopMotor(motorLeft);
    stopMotor(motorRight);
    delay(1000);
 	}
 	stopMotor(motorLeft);
 	stopMotor(motorRight);
}

void badge14() {
  setServo(servo, -127);
  delay(400);
	static int leastDark, leastDarkAt;
	leastDark = SensorValue[lightSensor];
	leastDarkAt = -127;
  for (int i = -126; i <= 127; i++) {
    setServo(servo, i);
  	delay(8);
  	if (SensorValue[lightSensor] < leastDark) {
  		leastDark = SensorValue[lightSensor];
  		leastDarkAt = i;
  	}
  }
  setServo(servo, leastDarkAt);
  delay(500);
  setServo(servo, 0);
  startMotor(leastDarkAt > 0 ? motorRight : motorLeft, 31);
  delay((long) abs(leastDarkAt) * 1000 * 60 / 90 / 127);
  stopMotor(motorLeft);
  stopMotor(motorRight);
}

void badge16() {
	startMotor(motorLeft, 63);
	startMotor(motorRight, 63);
	SensorValue[encoder] = 0;
  while (SensorValue[encoder] > (240 - 1800)) {}
	stopMotor(motorLeft);
	stopMotor(motorRight);
  delay(1500);
  startMotor(motorLeft, 31);
	SensorValue[encoder] = 0;
  while (SensorValue[encoder] > -1600) {
  	long value = SensorValue[sonar];
  	if (value < 370 && value != -1) {
  		writeDebugStreamLine("Stopped for %i", value);
      stopMotor(motorLeft);
      for (int i = 0; i < 5; i++) {
        turnFlashlightOn(light);
        delay(500);
        turnFlashlightOff(light);
        delay(500);
      }
  		break;
  	}
  }
	stopMotor(motorLeft);
}

void badge17() {
	startMotor(motorLeft, 63);
	startMotor(motorRight, 63);
	SensorValue[encoder] = 0;
  while (SensorValue[encoder] > (240 - 1800)) {}
	stopMotor(motorLeft);
	stopMotor(motorRight);
  delay(1500);
  startMotor(motorLeft, 31);
	static int closest, closestPosition;
	closest = SensorValue[sonar];
	closestPosition = 0;
	SensorValue[encoder] = 0;
  while (SensorValue[encoder] > -1520) {
  	int value = SensorValue[sonar];
  	if (closest == -1 || (value != -1 && value < closest)) {
  		closest = value;
  		closestPosition = SensorValue[encoder];
  	}
  }
  startMotor(motorLeft, -31);
  while (SensorValue[encoder] < closestPosition) {
  }
  stopMotor(motorLeft);
  delay(1500);
	startMotor(motorLeft, 63);
	startMotor(motorRight, 63);
	SensorValue[encoder] = 0;
  while (SensorValue[encoder] > -360) {}
	stopMotor(motorLeft);
	stopMotor(motorRight);
/*while (
  		closestPosition = SensorValue[encoder];
  	if (value < 370 && value != -1) {
  		writeDebugStreamLine("Stopped for %i", value);
      stopMotor(motorLeft);
  		break;
  	}*/
}

void badge4() {
  //motor[leftMotor] = 127;
  startMotor(motorLeft, 127);
  delay(5000);
  stopMotor(motorLeft);
}

void badge5() {
  startMotor(motorLeft, 127);
  startMotor(motorRight, -127);
  delay(1600);
  stopMotor(motorLeft);
  stopMotor(motorRight);
  delay(1000);
  startMotor(motorLeft, -63);
  startMotor(motorRight, 63);
  delay(1650);
  stopMotor(motorLeft);
  stopMotor(motorRight);
}

void badge6() {
  for (int i = 0; i < 4; i++) {
    startMotor(motorLeft, 63);
    startMotor(motorRight, 63);
    delay(2800);
    startMotor(motorLeft, 35);
    startMotor(motorRight, 0);
    delay(1350);
    stopMotor(motorLeft);
    stopMotor(motorRight);
    delay(1000);
  }
}

void badge7() {
  static int limit1 = -1254;
  static int limit2 = -1728;
  for (int i = 0; i < 4; i++) {
  	SensorValue[encoder] = 0;
    startMotor(motorLeft, 68);
    startMotor(motorRight, 63);
    while (SensorValue[encoder] > limit1) {}
    writeDebugStreamLine("Turn At %d", SensorValue[encoder]);
    startMotor(motorLeft, 35);
    startMotor(motorRight, 0);
    while (SensorValue[encoder] > limit2) {}
    writeDebugStreamLine("Stop At %d", SensorValue[encoder]);
    stopMotor(motorLeft);
    stopMotor(motorRight);
    delay(1000);
  }
}

void badge8() {
  turnFlashlightOff(light);
  startMotor(motorLeft, 127);
  startMotor(motorRight, 127);
  while (SensorValue[sonar] > 470) {}
  turnFlashlightOn(light);
  while (SensorValue[sonar] > 370) {
    delay(20);
    turnFlashlightOff(light);
    delay(20);
    turnFlashlightOn(light);
  }
  stopMotor(motorLeft);
  stopMotor(motorRight);
  turnFlashlightOff(light);
}

void badge9() {
	int scale = 1;
	bool pressed = false;
  while (true) {
  	int potent = SensorValue[potentiometer];
  	if (SensorValue[touch1]) {
  		if (!pressed) scale *= -1;
  		pressed = true;
  	} else {
  	  pressed = false;
  	}
  	if (potent == 0) {
  		break;
    } else if (potent < 1024) {
      stopMotor(motorLeft);
      stopMotor(motorRight);
    } else if (potent < 2048) {
      startMotor(motorLeft, 31 * scale);
      startMotor(motorRight, 31 * scale);
    } else if (potent < 3072) {
      startMotor(motorLeft, 63 * scale);
      startMotor(motorRight, 63 * scale);
    } else {
      startMotor(motorLeft, 127 * scale);
      startMotor(motorRight, 127 * scale);
    }
  }
  stopMotor(motorLeft);
  stopMotor(motorRight);
}

void untilReleased(int button) {
  while (true) {
  	int count = 0;
  	for (int i = 0; i < 3; i++) {
    	delay(100);
    	if (!SensorValue[button]) {
    		count++;
    	}
    }
    if (count == 3) {
    	return;
    }
  }
}

int getDial() {
	// returns 0 to 9, inclusive
	int limits[] = { 0, 111, 653, 1136, 1603, 2100, 2643, 3224, 3832, 4095 };
	int potent = SensorValue[potentiometer];
	for (int i = 0; i <= 8; i++)
		if (potent < (limits[i] + limits[i + 1]) / 2)
			return i;
	return potent == 4095 ? 9 : 8;
}

task main() {
  clearDebugStream();
  while (true) {
  	static int dialPosition = 0;
  	dialPosition = getDial();
    if (SensorValue[touch1] == 1 || SensorValue[touch2] == 1) {
    	switch (getDial()) {
    		case 1: badge11(); break;
    		case 2: badge12(); break;
    		case 3: badge13(); break;
    		case 4: badge14(); break;
    		case 5: badge5(); break;
    		case 6: badge16(); break;
    		case 7: badge17(); break;
    		case 8: badge8(); break;
    		case 9: badge9(); break;
    	}
    	untilReleased(touch2);
    }
  }

}
